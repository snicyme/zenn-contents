---
title: 'ElectronでのOpenID Connectを考えた'
emoji: '⚛️'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['electron', 'oauth2', 'twitch']
published: true
---

## この記事は過去記事です

過去に `Twitch` のコメビュを作成する際に投稿した記事を Zenn に持ってきたものです。今 `Electron` で認証を使う場合は以下の記事がいいと思います。

`Twitch` 用に `Auth0` で細工が必要ですが...

https://zenn.dev/snicyme/articles/013551228adfa0

## ちなみに

私は認証周りのスペシャリストではありません。

いろいろ触ってトライはしますが深く探って考察するタイプではないのです 😇 ある程度納得のいくまで情報を集めて消化して次へ行ってしまいます 😅 おかしな部分もたくさんあるかと思いますがご了承ください。

## 作ろうとしているもの

動画ストリーミングサービスを対象とした「Mac で動く」コメントビューアー。

`Electron` にした理由は、棒読みちゃんの `Mac` での代替を作成し連携させたかった。ちなみに初めは `Twitch` のみをサポート、よってこの記事は `Twitch` を念頭に置いたものとします。アプリケーションサービスへのログインが目的ではなく、各サービスのチャットメッセージなどを取得するためにアクセストークンを発行させるのが目的です。

## 使うもの

### Electron

立案時は Web アプリにしようと思っていたのですが、棒読みちゃん代替との連携を考えると `Electron` にするのが一番と考えました。Windows 版も作成できますしね 👍

### OpenID Connect(node-openid-client)

当初は `NPMパッケージ` で `OAuth2.0` で認証をと考えていましたが、`Twitch` の場合 `PKCE` に対応していないので、ネイティブアプリケーションでは「乗っ取り」「乗っ取られ」が発生する可能性がありました。

### Node による自前サーバー

`Client Secret` などを内包し対象サービスのリダイレクト先に自前サーバーを立てて対応します。

## 画像でフローを並べていく

では、冗長ですが実際のフローを並べていきたいと思います 🤗

### 認証フロー 1/16

![フロー1](/images/openid_0001.png)

`Electron` で `UUIDv4` にてキーを発行しサーバーに `REST` でキック

### 認証フロー 2/16

![フロー2](/images/openid_0002.png)

サーバーは `キーA` を受け取り、`node-open-id-client` にて `nonce` を発行します。この `nonce` は後で引き回してセキュリティチェックに使用しますが、ここからは `キーB` として扱います。

### 認証フロー 3/16

![フロー3](/images/openid_0003.png)

`KeyValue` なデータベース `Redis` に、`nance` である `キーB` を key として `キーA` を保存します（ややこしや

ちなみにこのデータは有効期限 10 秒を設定しておきます。連続してアクセスされるとパンクする恐れがあるのと消えるまでにログインさせることで多少なりともセキュリティ対策です。

### 認証フロー 4/16

![フロー4](/images/openid_0004.png)

`キーB` を使って `AuthURL` を発行します、この時対象サービスの `AppID` などももちろん使用します。

### 認証フロー 5/16

![フロー5](/images/openid_0005.png)

クライアントへ `キーB` と`認証用URL` を返します。URL はクライアントで開く為です。

### 認証フロー 6/16

![フロー6](/images/openid_0006.png)

今度は `WebSocket` で自前サーバーに接続します。この時 `キーAB` を渡し、サーバーでは `Redis` にデータがあるかどうかでログイン不可を決めます。

### 認証フロー 7/16

![フロー7](/images/openid_0007.png)

ログインし `キーB` 専用 `room` に `join` できた場合 `Redis` から情報を削除します。`Redis` にデータがないのでこれ以上同じ `キーB` でログインができなくなるはずです。

### 認証フロー 8/16

![フロー8](/images/openid_0008.png)

ログインし `キーB` 専用 `room` に `join` できた場合 `Redis` から情報を削除します。`Redis` にデータがないのでこれ以上同じ `キーB` でログインができなくなるはずです。

### 認証フロー 9/16

![フロー9](/images/openid_0009.png)

`WebSocket` が繋がったのでローカルのキーは不要、削除します。`認証用URL` をブラウザで開いで`認証用URL` も破棄します。

### 認証フロー 10/16

![フロー10](/images/openid_0010.png)

ユーザーが認証作業を進めます。ログインや App に渡す権限などをチェックし許可する作業です。

### 認証フロー 11/16

![フロー11](/images/openid_0011.png)

ユーザーによる認証作業が無事完了した場合、設定してある URL へリダイレクトされます、この場合自前サーバーにリダイレクトされ認証コード(今後は `キーC`)と `キーB` が通知されます。

`キーB` の `room` が存在しているかチェックを入れた方がいいですね、`room` がなければ不正もしくは切断されている処理なのでエラーとすることができます。

### 認証フロー 12/16

![フロー12](/images/openid_0012.png)

`キーB` は置いといて `キーC` を使って対象のサービスにトークン発行を申請します。

### 認証フロー 13/16

![フロー13](/images/openid_0013.png)

認証コードが正常ならトークン各種を取得できます。

### 認証フロー 14/16

![フロー14](/images/openid_0014.png)

取得できたトークン各種のなかに `id_token` 情報が含まれており、さらにその中に `キーB` が入っています。すでに持っていた `キーB` と `id_token` の `キーB` を照合します。

### 認証フロー 15/16

![フロー15](/images/openid_0015.png)

`キーB` に問題がなければ接続済みの `WebSocket` を使ってクライアントにトークンを渡してサーバー側は完了です。

ここで `キーB` が合致しなければ攻撃を受けている可能性がありますのでエラーとなります。

### 認証フロー 16/16

![フロー16](/images/openid_0016.png)

あとはトークンを使って情報を取得するなり投稿するなりなんなりと〜。

ちなみに `refresh token` も含まれているので、次回以降はこの `refresh token` を自前サーバーに渡して新しい `access token` を取得することで、ユーザーが再度認可処理を行わなくても済むという寸法です。

## 認証が不可欠でした

使おうとしている `NPMパッケージ` がログイン前提にしているというのもあるのですが、コメント表示だけでなく「プレーンテキストの投稿機能」は付けたかった。

投稿するにはログインが必要なので初めからログイン前提としました。Windows 向けのコメントビューアには認証がいらないものがあり、どういう仕組みなのか興味はありますが、NPM のエコシステムにどっかり乗りたいのです 😆

## 認証フローは Code Flow で行う

`OpenID Connect` は複数のアプローチで認証が可能ですが、`refresh token` で `access token` を更新しながら使用できる方を使用しました。

## 自前サーバーに認証用 URL を発行させる

`認証用URL` の発行は `Electron` でも可能なのですが、発行された `access token` を受け取る方法に悩みました。自前サーバーに`認証用URL` を発行してもらった次のタイミングで `socket.io` にて匿名ログインし最終的は各種トークンを `socket.io` 経由で受け取るとしました。

自前サーバーで発行することで後々エンドポイントが変わったり(ないと思うけど)と言ったことに対応できるメリットもあります。

## Electron ではなくブラウザを経由

`Electron` の `BrowserWindow` で`認証用URL` を表示すればアクセストークンなどを直接読み込むことが可能で面倒が少ないのです。

ですが、ユーザーが日頃使用しているブラウザを使うことで各種サービスへの再ログイン作業を行わなくて済むメリットがあります。

また、`BrowserWindow` を使うと色々なことができてしまうのと偽造ページを表示していてもユーザーに見分けがつかないのでセキュリティ的にアレのソレということのようですね。

`Auth0` のサンプルなどをみると `BrowserWindow` を使用したものしか出てこない(知らないだけかも 🤔)ので、悪意がなければ OK なのかもしれませんが、UX としてはブラウザを経由したほうがいいと思います。

## 認証のリダイレクト先を自前サーバーに

ここを `Custom URL Scheme` にしたり、`Electron` の Main プロセスで Express を動かして localhost をリダイレクト先にして受け取る〜などの手法があるようですね。

トークンを発行するのに各サービスにアプリケーション登録を行う必要があり、登録時に ID とシークレットキーを取得できますが、ID の方は公開されて問題ないのですがシークレットキーの方は極秘なので、ネイティブ App 内に持つのは御法度のようですね、なのでシークレットキーはサーバーに保持するのですがこの為に自前サーバーを用意していると言っても過言ではありません。

`Custom URL Scheme` は面白いなーと思ったのですが、なりすましが可能なので使うのが難しいですね。認証以外に使うのも面白そうと思いましたが、毎回ダイアログで「この URL を(アプリ名)に渡しちゃうよ？」と毎回聞いてくるので、今のところ使いどころが思いつきません 🤔

## アクセストークンの受け取り方

上にも書きましたが`認証用URL` を発行した段階でサーバーに `socket.io` にてログイン＋接続済みとなり、各サービスからリダイレクトで自前サーバーにコードが渡りアクセストークンの要求が済んだ段階で `socket.io` を経由して `Electron` へ情報を流すという形です。

これだけの為に `socket.io` を使うのもアレだなぁと思い `REST` でやればいいんじゃ？と思いましたが。

しかし `REST` だと認証完了後に「ユーザーにボタンを押してもらう」「`Custom URL Scheme` で `Electron` に通知して処理を続行させる」もしくは、サーバーに「トークンとれた？ねぇねぇ！とれた？」とポーリングしないといけないので、認証が完了した瞬間に `Electron` での処理が自動で走る方が負荷や UX 面でメリットがあると考えました。

これはこれでめんどくさいし問題が発生する可能性もありますが 😇

## あとがき

なげぇよ！🙇‍♂️

`refresh token` の処理などはまた別途必要になりますが、そちらは認証はいらないので簡単に行くはずです。

`PKCE` などを使えば `OAuth2` でも同じようなことが可能になりますが、冒頭でも明示したように `Twitch` に接続するところから始まっており、残念あがら `Twitch` は `PKCE` をサポートしていないようでしたので OIDC を使うことにしました。

当初 `OIDC` でどのようにネイティブアプリ＋認証をある程度のセキュリティで行うのかな？と思っていましたが、`nonce` が答えだったのではないかと思っております。

もしかしたらヤバイ部分があるかもしれませんが 💦 今はとりあえずこの方向で進んでいこうかなぁ 🤔

## その後

`Auth0` でのソーシャルログインで `Twitch` のコネクションを作成すれば `Auth0` のシステムに乗っかれて手軽に `access token` と `refresh token` を取得できます。考えることが減るのでおすすめです。
